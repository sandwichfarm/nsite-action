name: 'nsite Action'
description: 'Deploys static website files to Blossom/Nostr using the nsyte CLI.'
author: 'nsite-action Developers' # Placeholder

inputs:
  nsyte_version:
    description: 'The version of the nsyte CLI to use (e.g., "v0.3.6", "latest"). Needs to match a tag in github.com/sandwichfarm/nsyte/releases'
    required: false
    default: 'latest'
  nbunksec:
    description: 'The nbunksec string for authentication via NIP-46 bunker. Store this as a GitHub Secret.'
    required: true
  directory:
    description: 'The directory containing the static files to upload.'
    required: true
  force:
    description: 'Corresponds to the --force flag in nsyte upload. Re-upload all files.'
    required: false
    default: 'false'
  purge:
    description: 'Corresponds to the --purge flag in nsyte upload. Delete remote files not present locally.'
    required: false
    default: 'false'
  verbose:
    description: 'Corresponds to the --verbose flag in nsyte upload. Show detailed output.'
    required: false
    default: 'false'
  concurrency:
    description: 'Corresponds to the --concurrency flag in nsyte upload. Number of parallel uploads.'
    required: false
    default: '4'
  fallback:
    description: 'Corresponds to the --fallback flag in nsyte upload. Path to the fallback HTML file (e.g., /index.html for SPAs).'
    required: false
    default: '' # Default is no fallback specified to nsyte

outputs:
  status:
    description: 'Status of the upload operation (e.g., "success"). More detailed outputs might be added later.'
  nsyte_version:
    description: 'The actual version of nsyte that was downloaded and used.'

branding:
  icon: 'upload-cloud'
  color: 'purple'

runs:
  using: 'composite'
  steps:
    - name: Determine Platform
      id: platform
      shell: bash
      run: |
        # Simplified platform detection based on actual nsyte release naming
        PLATFORM=""
        EXE_SUFFIX=""

        if [[ "${{ runner.os }}" == "Linux" ]]; then 
          PLATFORM="linux"
        elif [[ "${{ runner.os }}" == "macOS" ]]; then 
          PLATFORM="macos"
        elif [[ "${{ runner.os }}" == "Windows" ]]; then
          PLATFORM="windows"
          EXE_SUFFIX=".exe"
        else
          echo "::error::Unsupported runner OS: ${{ runner.os }}"
          exit 1
        fi

        echo "Detected platform: $PLATFORM"
        echo "platform=$PLATFORM" >> $GITHUB_OUTPUT
        echo "exe_suffix=$EXE_SUFFIX" >> $GITHUB_OUTPUT

    - name: Set nsyte Version
      id: version
      shell: bash
      # Use gh cli if available (preferred), otherwise fallback to curl/jq
      run: |
        NSYTE_VERSION_INPUT="${{ inputs.nsyte_version }}"
        NSYTE_VERSION_FINAL=""
        VERSION_NUMBER=""

        if [[ "$NSYTE_VERSION_INPUT" == "latest" ]]; then
          echo "Input version is 'latest', resolving..."
          GH_AVAILABLE=false
          
          # First check if gh CLI is available and functioning with auth
          if command -v gh &> /dev/null; then
            echo "gh CLI found, attempting to use it..."
            # Test if GH_TOKEN is available by running a simple command
            if gh api repos/sandwichfarm/nsyte &> /dev/null; then
              GH_AVAILABLE=true
              echo "Using 'gh' CLI to find latest release."
              LATEST_TAG=$(gh release list -R sandwichfarm/nsyte --limit 1 --json tagName --jq '.[0].tagName' 2>/dev/null)
              if [[ -z "$LATEST_TAG" ]]; then
                 echo "::warning::Could not determine latest release tag using gh CLI. Will try API instead."
                 GH_AVAILABLE=false
              else
                NSYTE_VERSION_FINAL="$LATEST_TAG"
                echo "Resolved latest version: $NSYTE_VERSION_FINAL"
              fi
            else
              echo "::warning::gh CLI found but lacks authentication. Will try API instead."
              GH_AVAILABLE=false
            fi
          else
            echo "gh CLI not available, will use direct API call."
            GH_AVAILABLE=false
          fi
          
          # If gh CLI failed or not available, fall back to direct API call
          if [[ "$GH_AVAILABLE" != "true" ]]; then
            echo "Using GitHub API to find latest release."
            # Try first with curl/jq
            if command -v jq &> /dev/null; then
              LATEST_TAG=$(curl -s -H "Accept: application/vnd.github.v3+json" https://api.github.com/repos/sandwichfarm/nsyte/releases/latest | jq -r '.tag_name')
              if [[ -z "$LATEST_TAG" || "$LATEST_TAG" == "null" ]]; then
                echo "::warning::Could not determine latest release tag using GitHub API and jq."
                # Last resort: try with curl and grep/cut for parsing
                LATEST_TAG=$(curl -s https://api.github.com/repos/sandwichfarm/nsyte/releases/latest | grep -o '"tag_name": "[^"]*' | cut -d'"' -f4)
                if [[ -z "$LATEST_TAG" || "$LATEST_TAG" == "null" ]]; then
                  echo "::error::Failed to determine latest release tag. Please specify an explicit nsyte_version."
                  exit 1
                fi
              fi
            else
              # If jq not available, try with grep/cut
              echo "jq not available, using curl with grep/cut for parsing."
              LATEST_TAG=$(curl -s https://api.github.com/repos/sandwichfarm/nsyte/releases/latest | grep -o '"tag_name": "[^"]*' | cut -d'"' -f4)
              if [[ -z "$LATEST_TAG" || "$LATEST_TAG" == "null" ]]; then
                echo "::error::Failed to determine latest release tag. Please specify an explicit nsyte_version."
                exit 1
              fi
            fi
            NSYTE_VERSION_FINAL="$LATEST_TAG"
            echo "Resolved latest version using API: $NSYTE_VERSION_FINAL"
          fi
        else
          echo "Using specified version: $NSYTE_VERSION_INPUT"
          NSYTE_VERSION_FINAL="$NSYTE_VERSION_INPUT"
        fi

        # Extract just the version number without 'v' prefix for the filename
        if [[ "$NSYTE_VERSION_FINAL" =~ ^v(.+)$ ]]; then
            VERSION_NUMBER="${BASH_REMATCH[1]}"
        else
            VERSION_NUMBER="$NSYTE_VERSION_FINAL"
        fi
        
        echo "Extracted version number: $VERSION_NUMBER"
        echo "version=$NSYTE_VERSION_FINAL" >> $GITHUB_OUTPUT
        echo "version_number=$VERSION_NUMBER" >> $GITHUB_OUTPUT

    - name: Download and Extract nsyte
      id: download_extract
      shell: bash
      run: |
        VERSION="${{ steps.version.outputs.version }}"
        VERSION_NUMBER="${{ steps.version.outputs.version_number }}"
        PLATFORM="${{ steps.platform.outputs.platform }}"
        EXE_SUFFIX="${{ steps.platform.outputs.exe_suffix }}"

        # Construct asset filename based on actual naming pattern:
        # nsyte-linux-0.5.0, nsyte-macos-0.5.0, nsyte-windows-0.5.0.exe
        ASSET_FILENAME="nsyte-$PLATFORM-$VERSION_NUMBER$EXE_SUFFIX"
        DOWNLOAD_URL="https://github.com/sandwichfarm/nsyte/releases/download/${VERSION}/${ASSET_FILENAME}"

        echo "Downloading nsyte $VERSION for $PLATFORM..."
        echo "Download URL: $DOWNLOAD_URL"

        # Create a download directory
        mkdir -p nsyte_download
        cd nsyte_download

        # Use curl with error handling
        echo "Downloading asset file..."
        HTTP_STATUS=$(curl -sL -w "%{http_code}" -o "$ASSET_FILENAME" "$DOWNLOAD_URL")
        
        if [[ "$HTTP_STATUS" != "200" ]]; then
          echo "::error::Failed to download nsyte binary from $DOWNLOAD_URL. HTTP Status: $HTTP_STATUS"
          echo "Listing available assets for $VERSION to help with debugging:"
          
          # Try to list available assets for debugging
          if command -v gh &> /dev/null && [[ -n "$GH_TOKEN" ]]; then
            gh release view "$VERSION" -R sandwichfarm/nsyte --json assets --jq '.assets[].name' 2>/dev/null || echo "Could not list assets with gh CLI"
          else
            curl -s "https://api.github.com/repos/sandwichfarm/nsyte/releases/tags/$VERSION" | grep -o '"name": "[^"]*' | cut -d'"' -f4 || echo "Could not list assets with API"
          fi
          
          exit 1
        fi

        # Make the binary executable
        chmod +x "$ASSET_FILENAME"
        
        # Move back to original directory
        cd ..
        
        BINARY_PATH="$(pwd)/nsyte_download/$ASSET_FILENAME"
        echo "nsyte binary path: $BINARY_PATH"
        echo "nsyte_path=$BINARY_PATH" >> $GITHUB_OUTPUT

    - name: Build nsyte command
      id: build_cmd
      shell: bash
      run: |
        # Use GITHUB_OUTPUT for potentially long command
        {
          echo -n "command=${{ steps.download_extract.outputs.nsyte_path }} upload '${{ inputs.directory }}' --nbunksec '${{ inputs.nbunksec }} --non-interactive'"
          if [[ "${{ inputs.force }}" == "true" ]]; then echo -n " --force"; fi
          if [[ "${{ inputs.purge }}" == "true" ]]; then echo -n " --purge"; fi
          if [[ "${{ inputs.verbose }}" == "true" ]]; then echo -n " --verbose"; fi

          # Only add fallback if it's not empty
          if [[ -n "${{ inputs.fallback }}" ]]; then echo -n " --fallback '${{ inputs.fallback }}'"; fi
          
          # Add concurrency, basic check for non empty
          if [[ -n "${{ inputs.concurrency }}" ]]; then echo -n " --concurrency ${{ inputs.concurrency }}"; fi
        } >> $GITHUB_OUTPUT

    - name: Run nsyte upload
      id: nsyte_run
      shell: bash
      run: |
        NSYTE_COMMAND="${{ steps.build_cmd.outputs.command }}"
        echo "Executing nsyte command:"
        # Mask the nbunksec value in the log output for security
        MASKED_COMMAND=$(echo "$NSYTE_COMMAND" | sed 's/--nbunksec '\''[^'\'']*'\''/--nbunksec '\''***MASKED***'\''/')
        echo "$MASKED_COMMAND"

        if $NSYTE_COMMAND; then
           echo "nsyte upload completed successfully."
           echo "status=success" >> $GITHUB_OUTPUT
        else
           echo "::error::nsyte upload command failed with exit code $?."
           echo "status=failure" >> $GITHUB_OUTPUT
           exit 1
        fi
        echo "nsyte_version=${{ steps.version.outputs.version }}" >> $GITHUB_OUTPUT 